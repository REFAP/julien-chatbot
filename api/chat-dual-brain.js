// api/chat-dual-brain.js
// Version avec vraies APIs Claude + OpenAI connect√©es

export default async function handler(req, res) {
    // CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { message, userData = {}, sessionId, action } = req.body;

        // Si c'est une action Airtable, g√©rer s√©par√©ment
        if (action) {
            return handleAirtableAction(req, res);
        }

        if (!message) {
            return res.status(400).json({ error: 'Message requis' });
        }

        console.log('üß† Dual Brain R√âEL d√©marr√©:', { message, userData, sessionId });

        // 1. ANALYSE UTILISATEUR ET QUESTION
        const analysis = analyzeUserAndQuestion(message, userData);
        console.log('üìä Analyse:', analysis);

        // 2. APPEL SYST√àME INTELLIGENT R√âEL
        const aiResponse = await callRealIntelligentSystem(message, analysis);
        console.log('ü§ñ R√©ponse IA:', aiResponse.mode);

        // 3. CIRCUIT DE R√âCOMPENSE
        const rewardStrategy = generateRewardStrategy(analysis.userLevel, analysis.questionType);

        // 4. G√âN√âRATION LEAD SI APPLICABLE
        let leadInfo = null;
        if (analysis.userLevel > 0 && analysis.leadValue > 0) {
            leadInfo = {
                leadId: `lead_${Date.now()}`,
                value: analysis.leadValue,
                partner: analysis.partner,
                status: 'generated'
            };
        }

        // 5. R√âPONSE FINALE
        return res.status(200).json({
            success: true,
            message: aiResponse.text,
            strategy: aiResponse.strategy,
            aiMood: aiResponse.mood,
            score: aiResponse.score,
            timestamp: new Date().toISOString(),
            isPremium: analysis.userLevel > 0,

            // Syst√®me de r√©compense
            rewardSystem: {
                userLevel: analysis.userLevel,
                levelName: analysis.levelName,
                conversionStrategy: rewardStrategy,
                leadValue: analysis.leadValue,
                partner: analysis.partner
            },

            // Informations business
            leadInfo,
            
            // M√©tadonn√©es
            metadata: {
                questionType: analysis.questionType,
                aiMode: aiResponse.mode,
                processingTime: aiResponse.processingTime,
                sessionId
            }
        });

    } catch (error) {
        console.error('üí• Erreur Dual Brain:', error);
        
        return res.status(200).json({
            success: true,
            message: "Je rencontre un probl√®me technique temporaire. Peux-tu reformuler ta question ? üîß",
            strategy: "error_fallback",
            score: 5.0,
            timestamp: new Date().toISOString(),
            error: "Fallback mode activ√©"
        });
    }
}

// SYST√àME INTELLIGENT R√âEL avec APIs
async function callRealIntelligentSystem(message, analysis) {
    const startTime = Date.now();

    // Configuration APIs avec vos vraies cl√©s
    const config = {
        claude: process.env.CLAUDE_API_KEY,
        openai: process.env.CLE_API_OPENAI
    };

    try {
        if (analysis.userLevel >= 1 && config.claude && config.openai) {
            // MODE DUAL BRAIN COMPLET
            console.log('üî• Mode Dual Brain R√âEL activ√©');
            return await callRealDualBrain(message, analysis, config, startTime);
            
        } else if (config.claude) {
            // MODE CLAUDE SEUL
            console.log('üéØ Mode Claude R√âEL seul');
            return await callRealClaude(message, analysis, config, startTime);
            
        } else if (config.openai) {
            // MODE OPENAI SEUL
            console.log('üí¨ Mode OpenAI R√âEL seul');
            return await callRealOpenAI(message, analysis, config, startTime);
            
        } else {
            // FALLBACK SIMULATION INTELLIGENTE
            console.log('üß† Fallback simulation intelligente');
            return generateIntelligentSimulation(message, analysis, startTime);
        }

    } catch (error) {
        console.error('‚ùå Erreur APIs:', error);
        console.log('üîÑ Fallback vers simulation intelligente');
        return generateIntelligentSimulation(message, analysis, startTime);
    }
}

// DUAL BRAIN R√âEL CLAUDE + OPENAI
async function callRealDualBrain(message, analysis, config, startTime) {
    try {
        console.log('üöÄ Lancement Dual Brain en parall√®le...');

        // Prompts optimis√©s pour chaque IA
        const claudePrompt = generateClaudePrompt(message, analysis);
        const openaiPrompt = generateOpenAIPrompt(message, analysis);

        // Appels parall√®les aux vraies APIs
        const [claudeResponse, openaiResponse] = await Promise.all([
            callClaudeAPI(claudePrompt, config.claude),
            callOpenAIAPI(openaiPrompt, config.openai)
        ]);

        console.log('‚úÖ Dual Brain: Claude + OpenAI r√©ussis');

        // Fusion intelligente
        const fusedText = fuseResponses(claudeResponse, openaiResponse, analysis);

        return {
            text: fusedText,
            strategy: "dual_brain_real",
            mood: "expert_premium_dual",
            score: 9.8,
            mode: "dual_brain_real",
            processingTime: Date.now() - startTime
        };

    } catch (error) {
        console.error('‚ùå Erreur Dual Brain r√©el:', error);
        throw error;
    }
}

// CLAUDE SEUL R√âEL
async function callRealClaude(message, analysis, config, startTime) {
    try {
        const prompt = generateClaudePrompt(message, analysis);
        const response = await callClaudeAPI(prompt, config.claude);

        console.log('‚úÖ Claude API r√©ussi');

        return {
            text: response,
            strategy: "claude_real_precision",
            mood: "expert_claude_real",
            score: 9.0,
            mode: "claude_real",
            processingTime: Date.now() - startTime
        };

    } catch (error) {
        console.error('‚ùå Erreur Claude r√©el:', error);
        throw error;
    }
}

// OPENAI SEUL R√âEL
async function callRealOpenAI(message, analysis, config, startTime) {
    try {
        const prompt = generateOpenAIPrompt(message, analysis);
        const response = await callOpenAIAPI(prompt, config.openai);

        console.log('‚úÖ OpenAI API r√©ussi');

        return {
            text: response,
            strategy: "openai_real_creative",
            mood: "expert_openai_real",
            score: 8.7,
            mode: "openai_real",
            processingTime: Date.now() - startTime
        };

    } catch (error) {
        console.error('‚ùå Erreur OpenAI r√©el:', error);
        throw error;
    }
}

// APPELS API R√âELS
async function callClaudeAPI(prompt, apiKey) {
    console.log('üì° Appel Claude API...');
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
            model: 'claude-3-5-sonnet-20241022', // MOD√àLE CORRIG√â
            max_tokens: 1000,
            messages: [{ 
                role: 'user', 
                content: prompt 
            }]
        })
    });

    if (!response.ok) {
        const errorData = await response.text();
        console.error('‚ùå Claude API Error:', response.status, errorData);
        throw new Error(`Claude API error: ${response.status} - ${errorData}`);
    }

    const data = await response.json();
    console.log('‚úÖ Claude API response re√ßu');
    return data.content[0].text;
}

async function callOpenAIAPI(prompt, apiKey) {
    console.log('üì° Appel OpenAI API...');
    
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            model: 'gpt-4o', // MOD√àLE R√âCENT
            messages: [{ 
                role: 'user', 
                content: prompt 
            }],
            max_tokens: 1000,
            temperature: 0.7
        })
    });

    if (!response.ok) {
        const errorData = await response.text();
        console.error('‚ùå OpenAI API Error:', response.status, errorData);
        throw new Error(`OpenAI API error: ${response.status} - ${errorData}`);
    }

    const data = await response.json();
    console.log('‚úÖ OpenAI API response re√ßu');
    return data.choices[0].message.content;
}

// G√âN√âRATION PROMPTS OPTIMIS√âS
function generateClaudePrompt(message, analysis) {
    return `Tu es Julien, expert automobile fran√ßais sp√©cialis√© FAP/EGR/AdBlue depuis 20 ans chez Re-Fap.

QUESTION CLIENT: "${message}"

CONTEXTE:
- Type probl√®me d√©tect√©: ${analysis.questionType}
- Niveau client: ${analysis.levelName}
- Urgence: ${analysis.urgency}

INSTRUCTIONS PR√âCISES:
${analysis.userLevel === 0 ? 
    `- Diagnostic de base professionnel
- Pose 2-3 questions techniques pr√©cises pour affiner
- NE CONCLUS PAS trop vite, demande des pr√©cisions
- Montre ton expertise sans √™tre commercial
- Termine par: "Avec ces infos, je pourrai te donner un diagnostic pr√©cis !"` :
    `- Diagnostic expert approfondi 
- Analyse technique d√©taill√©e
- Estimation co√ªts et solutions
- Recommandations personnalis√©es
- Ton d'expert premium`}

STYLE: Expert technique, rassurant, fran√ßais naturel. Maximum 150 mots.

R√©ponds uniquement en tant que Julien expert automobile.`;
}

function generateOpenAIPrompt(message, analysis) {
    return `Tu es Julien, expert automobile chaleureux et p√©dagogue de Re-Fap. Un client te dit:

"${message}"

CONTEXTE CLIENT:
- Niveau: ${analysis.levelName}
- Probl√®me type: ${analysis.questionType}

TON STYLE UNIQUE:
- Chaleureux mais expert
- Empathique et rassurant  
- Explications claires pour non-expert
- Encourage les bonnes d√©cisions
- Mentionne l'importance s√©curit√©

${analysis.userLevel === 0 ?
    'OBJECTIF: Rassurer, poser questions pertinentes, montrer expertise avant tout commercial' :
    'OBJECTIF: Conseil expert premium, solutions concr√®tes, accompagnement personnalis√©'}

R√©ponds comme un vrai expert automobile fran√ßais. Maximum 150 mots.`;
}

// FUSION INTELLIGENTE DES R√âPONSES
function fuseResponses(claudeResponse, openaiResponse, analysis) {
    if (analysis.userLevel >= 2) {
        // Utilisateurs premium : Claude (pr√©cision) puis OpenAI (engagement)
        return `${claudeResponse}\n\n---\n\nüí° **Conseil personnalis√© :** ${openaiResponse}`;
    } else {
        // Utilisateurs standards : OpenAI (engagement) puis Claude (technique)  
        return `${openaiResponse}\n\nüîß **Analyse technique :** ${claudeResponse}`;
    }
}

// üß† SIMULATION INTELLIGENTE (fallback si APIs √©chouent)
function generateIntelligentSimulation(message, analysis, startTime) {
    const messageLower = message.toLowerCase();
    let response = "";

    if (messageLower.includes('voyant moteur') || (messageLower.includes('voyant') && messageLower.includes('moteur'))) {
        if (analysis.userLevel === 0) {
            response = `**Voyant moteur d√©tect√©** üîß\n\nD'apr√®s mon exp√©rience, √ßa peut indiquer plusieurs choses selon la couleur et le comportement.\n\nüîç **Questions d'expert :**\n- Quelle couleur ? (Orange/rouge/jaune)\n- Il clignote ou reste fixe ?\n- Depuis quand ?\n- Autres sympt√¥mes ?\n\nAvec ces infos, diagnostic pr√©cis possible ! üë®‚Äçüîß`;
        } else {
            response = `**Diagnostic moteur premium** üéØ\n\nAnalyse approfondie du voyant moteur :\n\n‚Ä¢ Orange clignotant = FAP/EGR (80% des cas)\n‚Ä¢ Orange fixe = Capteur d√©faillant\n‚Ä¢ Rouge = Urgence moteur\n\nüí∞ **Estimations :**\n- Nettoyage FAP : 180‚Ç¨\n- Capteur : 150‚Ç¨\n- Intervention compl√®te : 350‚Ç¨\n\nDiagnostic pr√©cis recommand√© ! üîß`;
        }
    } else if (messageLower.includes('fap') || messageLower.includes('egr')) {
        response = `**Expertise FAP/EGR** üèÜ\n\nC'est exactement ma sp√©cialit√© ! Probl√®me ${analysis.questionType} d√©tect√©.\n\n${analysis.userLevel === 0 ? 
            'üîç Questions : Ville/autoroute ? Fum√©e ? Depuis quand ?\n\n80% des cas = encrassement r√©cup√©rable !' :
            'üí° Analyse premium : Encrassement progressif, solutions √©conomiques vs remplacement.\n\nüí∞ Nettoyage complet : 180‚Ç¨ vs 1200‚Ç¨ neuf !'}\n\nSolution personnalis√©e disponible ! üîß`;
    } else {
        response = `**Diagnostic automobile** üîß\n\nSalut ! Julien expert Re-Fap.\n\n${analysis.userLevel === 0 ?
            'üéØ Pour diagnostic pr√©cis :\n- Marque/mod√®le ?\n- Sympt√¥mes exacts ?\n- Depuis quand ?\n\nAvec √ßa, analyse compl√®te !' :
            'üèÜ Analyse premium activ√©e !\n\nDiagnostic approfondi avec solutions et co√ªts d√©taill√©s disponible.'}\n\nSp√©cialiste FAP/EGR/moteur ! üë®‚Äçüîß`;
    }

    return {
        text: response,
        strategy: "intelligent_simulation",
        mood: "expert_simulation", 
        score: 8.0,
        mode: "simulation_intelligent",
        processingTime: Date.now() - startTime
    };
}

// RESTE DU CODE (fonctions utilitaires inchang√©es)
function analyzeUserAndQuestion(message, userData) {
    let userLevel = 0;
    if (userData.email) userLevel = 1;
    if (userData.phone) userLevel = 2;
    if (userData.vehicleModel && userData.location) userLevel = 3;

    const questionType = detectQuestionType(message);
    const urgency = detectUrgency(message);
    const leadValue = calculateLeadValue(userLevel, questionType, urgency);
    const partner = getOptimalPartner(questionType, leadValue);

    return {
        userLevel,
        levelName: getLevelName(userLevel),
        questionType,
        urgency,
        leadValue,
        partner,
        canUpgrade: userLevel < 3
    };
}

function detectQuestionType(message) {
    const messageLower = message.toLowerCase();
    
    if (messageLower.includes('frein') || messageLower.includes('freinage')) return 'brakes';
    if (messageLower.includes('moteur') || messageLower.includes('voyant')) return 'engine';
    if (messageLower.includes('fap') || messageLower.includes('egr')) return 'engine';
    if (messageLower.includes('d√©marr') || messageLower.includes('batterie')) return 'electrical';
    if (messageLower.includes('boite') || messageLower.includes('vitesse')) return 'transmission';
    
    return 'general';
}

function detectUrgency(message) {
    const messageLower = message.toLowerCase();
    
    if (messageLower.includes('urgent') || messageLower.includes('panne') || messageLower.includes('ne d√©marre plus')) return 'high';
    if (messageLower.includes('bient√¥t') || messageLower.includes('pr√©voir')) return 'medium';
    
    return 'low';
}

function calculateLeadValue(userLevel, questionType, urgency) {
    const baseValues = {
        'engine': 40,
        'brakes': 35, 
        'transmission': 45,
        'electrical': 30,
        'general': 25
    };

    const urgencyMultiplier = {
        'high': 1.5,
        'medium': 1.2,
        'low': 1.0
    };

    const levelMultiplier = [0, 1, 1.8, 2.5][userLevel] || 1;

    return Math.round(
        (baseValues[questionType] || 25) * 
        urgencyMultiplier[urgency] * 
        levelMultiplier
    );
}

function getOptimalPartner(questionType, leadValue) {
    if (questionType === 'engine' && leadValue >= 40) return 'IDGARAGES';
    if (questionType === 'brakes') return 'MIDAS';
    return 'Re-Fap';
}

function getLevelName(userLevel) {
    const names = {
        0: 'Diagnostic de Base',
        1: 'Diagnostic Avanc√©', 
        2: 'Expertise Premium',
        3: 'Service VIP'
    };
    return names[userLevel] || 'Inconnu';
}

function generateRewardStrategy(userLevel, questionType) {
    if (userLevel === 0) {
        return {
            trigger: `üîì **Diagnostic ${questionType === 'engine' ? 'moteur' : questionType === 'brakes' ? 'freinage' : 'automobile'} complet disponible !**\n\nPour une analyse approfondie avec estimation pr√©cise des co√ªts, laissez simplement votre email.`,
            required: ['email', 'firstName', 'location'],
            reward: 'diagnostic premium avec estimation co√ªts'
        };
    } else if (userLevel === 1) {
        return {
            trigger: `üìû **Expert disponible pour vous rappeler !**\n\nUn de nos partenaires peut vous rappeler dans l'heure pour un devis personnalis√©.`,
            required: ['phone', 'vehicleModel'],
            reward: 'rappel expert personnalis√©'
        };
    }
    
    return null;
}

async function handleAirtableAction(req, res) {
    const { action, data } = req.body;
    
    if (action === 'CREATE_LEAD') {
        console.log('üìù Lead cr√©ation:', data);
        return res.status(200).json({
            success: true,
            leadId: `lead_${Date.now()}`,
            message: 'Lead cr√©√©'
        });
    }
    
    return res.status(200).json({
        success: true,
        message: 'Action trait√©e'
    });
}
