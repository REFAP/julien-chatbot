const express = require('express');
const cors = require('cors');
const path = require('path');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('.'));

// Configuration des APIs
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY;

// ==================== BASE CONVERSATIONNELLE FAP COMPL√àTE ====================
const FAP_CONVERSATION_DATABASE = {
  
  conversation_steps: {
    'welcome': {
      message: "Bonjour ! Je suis Julien, votre expert FAP Re-Fap. D√©crivez-moi le probl√®me que vous rencontrez avec votre v√©hicule.",
      type: 'open_text',
      fap_keywords: ['voyant', 'fap', 'filtre', 'particules', 'fum√©e', 'puissance', 'P2002', 'P2463', 'r√©g√©n√©ration', 'colmat√©'],
      next_if_fap: 'fap_symptom_detection',
      next_if_other: 'general_diagnosis'
    },

    'fap_symptom_detection': {
      message: "Parfait, je vais vous aider avec votre probl√®me de FAP. Le t√©moin de FAP (ou moteur) est-il allum√© sur votre tableau de bord ?",
      type: 'yes_no',
      options: {
        'oui': 'get_error_codes',
        'non': 'fap_physical_symptoms',
        'ne_sais_pas': 'explain_fap_warning'
      }
    },

    'explain_fap_warning': {
      message: "Le voyant FAP ressemble souvent √† un moteur orange, ou parfois √† un filtre avec des particules. Voyez-vous un voyant orange/rouge allum√© ?",
      type: 'yes_no',
      options: {
        'oui': 'get_error_codes',
        'non': 'fap_physical_symptoms'
      }
    },

    'get_error_codes': {
      message: "Avez-vous un code d'erreur ? (comme P2002, P2463, P244A, etc.) Si vous ne savez pas, je peux vous expliquer comment l'obtenir.",
      type: 'text_with_help',
      validation: /P[0-9A-F]{4}/gi,
      options: {
        'help': 'explain_obd_reading',
        'no_code': 'fap_symptoms_with_light'
      }
    },

    'fap_physical_symptoms': {
      message: "D'accord. Ressentez-vous une perte de puissance, surtout lors des acc√©l√©rations ?",
      type: 'yes_no',
      options: {
        'oui': 'check_fap_smoke',
        'non': 'check_fap_consumption'
      }
    },

    'check_fap_smoke': {
      message: "Y a-t-il de la fum√©e √† l'√©chappement ? Si oui, de quelle couleur ?",
      type: 'multiple_choice',
      options: {
        'aucune': 'fap_consumption_check',
        'noire': 'black_smoke_fap_analysis',
        'blanche': 'white_smoke_analysis',
        'bleue': 'other_engine_issue'
      }
    },

    'black_smoke_fap_analysis': {
      message: "Fum√©e noire = souvent FAP colmat√© ! Cette fum√©e appara√Æt-elle principalement √† l'acc√©l√©ration ou en permanence ?",
      type: 'multiple_choice',
      options: {
        'acceleration': 'fap_clogged_acceleration',
        'permanent': 'fap_severely_clogged',
        'demarrage_froid': 'fap_cold_start_issue'
      }
    },

    'fap_driving_analysis': {
      message: "Voici la question cl√© ! Faites-vous principalement des trajets urbains courts (moins de 15-20 min) ou des trajets plus longs sur route/autoroute ?",
      type: 'multiple_choice',
      options: {
        'urbain_court': 'urban_fap_issue',
        'mixte': 'mixed_driving_fap',
        'autoroute_long': 'highway_fap_ok',
        'tres_varie': 'varied_driving_fap'
      }
    },

    'urban_fap_issue': {
      message: "üö® Voil√† le probl√®me ! Les trajets urbains courts emp√™chent la r√©g√©n√©ration du FAP. Le FAP a besoin de 600¬∞C pour br√ªler la suie, impossible en ville ! √Ä quelle fr√©quence faites-vous des trajets d'autoroute de plus de 30 km ?",
      type: 'multiple_choice',
      education: "En ville, le moteur ne chauffe jamais assez longtemps. C'est comme essayer de nettoyer un four sale en ne l'allumant que 5 minutes !",
      options: {
        'jamais': 'critical_fap_regeneration_issue',
        'rarement': 'insufficient_fap_regeneration', 
        'parfois': 'occasional_fap_regeneration',
        'regulierement': 'sufficient_fap_regeneration'
      }
    },

    'critical_fap_regeneration_issue': {
      message: "üö® Situation critique ! Sans trajets longs, votre FAP ne peut JAMAIS se r√©g√©n√©rer naturellement. Pouvez-vous faire un trajet d'autoroute de 30+ km dans les 48h ?",
      type: 'yes_no',
      urgency: 'high',
      options: {
        'oui': 'emergency_fap_regeneration_protocol',
        'non': 'urgent_fap_professional_cleaning'
      }
    }
  },

  // Codes d'erreur FAP sp√©cialis√©s
  fap_error_codes: {
    'P2002': {
      title: "FAP - Efficacit√© en dessous du seuil",
      severity: 'high',
      confidence: 90,
      description: "Votre FAP ne filtre plus efficacement. Il est probablement colmat√© par la suie.",
      causes: [
        { cause: "Conduite urbaine exclusive", probability: 70, solution: "fap_regeneration_protocol" },
        { cause: "FAP satur√© en suie", probability: 85, solution: "professional_fap_cleaning" },
        { cause: "Capteur pression HS", probability: 10, solution: "sensor_replacement" }
      ],
      immediate_questions: ['driving_pattern', 'last_regeneration'],
      next_step: 'p2002_fap_deep_dive'
    },

    'P2463': {
      title: "Accumulation excessive de suie FAP",
      severity: 'critical',
      confidence: 95,
      description: "‚ö†Ô∏è Niveau de suie critique ! Intervention urgente n√©cessaire.",
      causes: [
        { cause: "Conduite urbaine excessive", probability: 80, solution: "immediate_regeneration" },
        { cause: "Injecteurs d√©fectueux", probability: 15, solution: "injector_cleaning" },
        { cause: "EGR encrass√©", probability: 5, solution: "egr_service" }
      ],
      urgency: 'immediate',
      next_step: 'p2463_emergency_protocol'
    },

    'P244A': {
      title: "Pression diff√©rentielle FAP trop faible",
      severity: 'medium',
      confidence: 75,
      description: "Capteur d√©tecte une pression anormalement basse. Possible fuite ou capteur d√©fectueux.",
      causes: [
        { cause: "Capteur pression d√©fectueux", probability: 60, solution: "sensor_diagnosis" },
        { cause: "Fuites conduits FAP", probability: 30, solution: "leak_inspection" },
        { cause: "FAP perc√©", probability: 10, solution: "fap_replacement" }
      ],
      next_step: 'p244a_sensor_check'
    },

    'P244B': {
      title: "Pression diff√©rentielle FAP trop √©lev√©e",
      severity: 'critical',
      confidence: 98,
      description: "üö® FAP COMPL√àTEMENT BOUCH√â ! Risque de panne imm√©diate.",
      emergency: true,
      causes: [
        { cause: "FAP totalement colmat√©", probability: 90, solution: "emergency_intervention" },
        { cause: "Capteur d√©fectueux", probability: 10, solution: "sensor_verification" }
      ],
      next_step: 'p244b_emergency_protocol'
    }
  },

  // Protocoles de solutions FAP
  fap_solution_protocols: {
    'emergency_fap_regeneration_protocol': {
      title: "üõ£Ô∏è PROTOCOLE R√âG√âN√âRATION D'URGENCE",
      type: 'self_service',
      steps: [
        "1. üîç V√©rifiez : minimum 1/4 de r√©servoir + huile OK",
        "2. üõ£Ô∏è Autoroute/route : 90+ km/h pendant 45 minutes MINIMUM",
        "3. ‚ö° Maintenez 3000+ tours/min si possible",
        "4. üö´ NE VOUS ARR√äTEZ PAS pendant la r√©g√©n√©ration",
        "5. üëÄ Observez : fum√©e blanche = r√©g√©n√©ration en cours",
        "6. ‚úÖ Continuez jusqu'√† disparition compl√®te des sympt√¥mes"
      ],
      warning: "‚ö†Ô∏è Si AUCUNE am√©lioration apr√®s 1h d'autoroute : ARR√äTEZ et appelez-nous !",
      success_rate: 70,
      cta: {
        type: 'urgent_self_service',
        followup_required: true,
        phone_support: true
      }
    },

    'urgent_fap_professional_cleaning': {
      title: "üîß NETTOYAGE FAP PROFESSIONNEL URGENT",
      type: 'professional_service',
      reason: "Votre FAP est trop colmat√© pour une r√©g√©n√©ration standard.",
      services: [
        {
          name: 'Nettoyage FAP Re-Fap Express',
          duration: '2h',
          success_rate: 95,
          warranty: '6 mois',
          urgency: 'same_day'
        },
        {
          name: 'Diagnostic complet + Nettoyage',
          duration: '3h',
          success_rate: 98,
          warranty: '12 mois',
          urgency: 'within_24h'
        }
      ],
      cta: {
        type: 'urgent_appointment',
        same_day_available: true
      }
    },

    'p244b_emergency_protocol': {
      title: "üö® PROTOCOLE D'URGENCE CRITIQUE",
      type: 'emergency',
      immediate_actions: [
        "üöó LIMITEZ la conduite au strict minimum",
        "üìû APPELEZ notre atelier IMM√âDIATEMENT",
        "üö´ N'essayez AUCUNE r√©g√©n√©ration",
        "üõë Si mode d√©grad√© activ√© : ARR√äTEZ-VOUS EN S√âCURIT√â"
      ],
      risk: "Risque de dommages moteur irr√©versibles",
      intervention: "Intervention professionnelle OBLIGATOIRE",
      cta: {
        type: 'emergency_call',
        priority: 'critical'
      }
    }
  }
};

// ==================== AUTRES CAS NON-FAP ====================
const OTHER_ISSUES_DATABASE = [
  {
    id: 'TURBO001',
    keywords: ['turbo', 'siffle', 'sifflement', 'suralimentation'],
    symptomes: 'Turbo qui siffle fort',
    causes_probables: 'Turbine en d√©but de jeu, durites perc√©es',
    solution: 'Contr√¥le visuel + test pression turbo',
    confidence: 0.8
  },
  {
    id: 'EGR001', 
    keywords: ['egr', 'vanne', 'prechauffage', 'clignote'],
    symptomes: 'Voyant pr√©chauffage qui clignote',
    causes_probables: 'Vanne EGR encrass√©e, capteur position d√©faillant',
    solution: 'Nettoyage ou remplacement vanne EGR',
    confidence: 0.8
  },
  {
    id: 'ADBLUE001',
    keywords: ['adblue', 'decompte', 'kilometrage', 'uree'],
    symptomes: 'Voyant AdBlue avec d√©compte',
    causes_probables: 'Qualit√© AdBlue douteuse, r√©servoir mal rempli',
    solution: 'Vidange AdBlue + remplissage certifi√©',
    confidence: 0.9
  }
];

// ==================== MOTEUR CONVERSATIONNEL ====================
class ConversationalFAPEngine {
  constructor() {
    this.fapDB = FAP_CONVERSATION_DATABASE;
    this.otherDB = OTHER_ISSUES_DATABASE;
  }

  async processMessage(userMessage, conversationState = null) {
    console.log(`üí¨ Message: "${userMessage}"`);

    // Nouveau utilisateur ou conversation termin√©e
    if (!conversationState || conversationState.step === 'completed') {
      return this.initializeConversation(userMessage);
    }

    // Continuer la conversation FAP en cours
    if (conversationState.category === 'fap') {
      return this.continueFAPConversation(userMessage, conversationState);
    }

    // Fallback g√©n√©ral
    return this.handleGeneralQuery(userMessage);
  }

  initializeConversation(userMessage) {
    const isFAPRelated = this.isFAPRelated(userMessage);
    
    if (isFAPRelated) {
      console.log('üîß D√©tection probl√®me FAP -> Mode conversationnel');
      return {
        message: this.fapDB.conversation_steps.fap_symptom_detection.message,
        type: 'fap_conversation',
        source: 'fap_expert',
        conversationState: {
          step: 'fap_symptom_detection',
          category: 'fap',
          collectedData: { initial_query: userMessage },
          confidence: 0
        }
      };
    } else {
      console.log('üîç Probl√®me non-FAP -> Recherche base g√©n√©rale');
      return this.handleNonFAPIssue(userMessage);
    }
  }

  isFAPRelated(message) {
    const fapKeywords = this.fapDB.conversation_steps.welcome.fap_keywords;
    const messageLower = message.toLowerCase();
    
    return fapKeywords.some(keyword => messageLower.includes(keyword)) ||
           /P2[0-4][0-9A-F]{2}/i.test(message); // Codes FAP
  }

  continueFAPConversation(userMessage, conversationState) {
    const currentStep = conversationState.step;
    const stepData = this.fapDB.conversation_steps[currentStep];
    
    if (!stepData) {
      console.error(`‚ùå √âtape inconnue: ${currentStep}`);
      return this.handleGeneralQuery(userMessage);
    }

    // Analyser la r√©ponse utilisateur
    const userResponse = this.parseUserResponse(userMessage, stepData);
    
    // Mettre √† jour les donn√©es collect√©es
    conversationState.collectedData[currentStep] = userResponse;
    
    // D√©terminer la prochaine √©tape
    const nextStep = this.determineNextFAPStep(userResponse, stepData, conversationState);
    
    // V√©rifier si on peut faire un diagnostic
    if (this.canProvideFAPDiagnosis(conversationState)) {
      return this.generateFAPDiagnosis(conversationState);
    }
    
    // Continuer la conversation
    const nextStepData = this.fapDB.conversation_steps[nextStep];
    conversationState.step = nextStep;
    conversationState.confidence = this.calculateFAPConfidence(conversationState.collectedData);
    
    return {
      message: nextStepData.message,
      type: 'fap_conversation',
      source: 'fap_expert',
      confidence: conversationState.confidence,
      conversationState: conversationState,
      options: nextStepData.options
    };
  }

  parseUserResponse(message, stepData) {
    const messageLower = message.toLowerCase();
    
    if (stepData.type === 'yes_no') {
      if (messageLower.includes('oui') || messageLower.includes('yes')) return 'oui';
      if (messageLower.includes('non') || messageLower.includes('no')) return 'non';
      if (messageLower.includes('sais pas') || messageLower.includes('know')) return 'ne_sais_pas';
    }
    
    if (stepData.validation) {
      const matches = message.match(stepData.validation);
      if (matches) return matches;
    }
    
    // Recherche dans les options multiples
    if (stepData.options) {
      for (const [key, value] of Object.entries(stepData.options)) {
        if (messageLower.includes(key.toLowerCase())) return key;
      }
    }
    
    return message; // Retour brut si pas de correspondance
  }

  determineNextFAPStep(userResponse, stepData, conversationState) {
    if (stepData.options && stepData.options[userResponse]) {
      return stepData.options[userResponse];
    }
    
    // Logique sp√©ciale pour les codes d'erreur
    if (Array.isArray(userResponse)) {
      const errorCode = userResponse[0];
      if (this.fapDB.fap_error_codes[errorCode]) {
        conversationState.detectedCode = errorCode;
        return this.fapDB.fap_error_codes[errorCode].next_step;
      }
    }
    
    // Par d√©faut, passer √† l'analyse de conduite
    return 'fap_driving_analysis';
  }

  generateFAPDiagnosis(conversationState) {
    const { collectedData, detectedCode } = conversationState;
    let diagnosis = "üîß **Diagnostic FAP Re-Fap**\n\n";
    let confidence = this.calculateFAPConfidence(collectedData);
    let ctas = [];

    // Diagnostic bas√© sur le code d'erreur
    if (detectedCode && this.fapDB.fap_error_codes[detectedCode]) {
      const codeData = this.fapDB.fap_error_codes[detectedCode];
      diagnosis += `**Code d√©tect√© :** ${detectedCode} - ${codeData.title}\n\n`;
      diagnosis += `**Description :** ${codeData.description}\n\n`;
      
      // Cause la plus probable
      const mainCause = codeData.causes.reduce((prev, current) => 
        prev.probability > current.probability ? prev : current
      );
      
      diagnosis += `**Cause principale (${mainCause.probability}%) :** ${mainCause.cause}\n\n`;
      
      // Solution recommand√©e
      const protocol = this.fapDB.fap_solution_protocols[mainCause.solution];
      if (protocol) {
        diagnosis += `**Solution recommand√©e :** ${protocol.title}\n\n`;
        if (protocol.steps) {
          diagnosis += protocol.steps.join('\n') + '\n\n';
        }
        if (protocol.warning) {
          diagnosis += `‚ö†Ô∏è ${protocol.warning}\n\n`;
        }
      }

      // CTA selon l'urgence
      if (codeData.emergency || codeData.urgency === 'immediate') {
        ctas.push({
          type: 'emergency',
          text: 'üö® Intervention urgente',
          action: 'emergency_call'
        });
      } else if (protocol?.type === 'self_service') {
        ctas.push({
          type: 'self_service',
          text: 'üõ£Ô∏è Essayer la r√©g√©n√©ration autoroute',
          action: 'highway_regeneration'
        });
      }
      
      ctas.push({
        type: 'professional',
        text: 'üîß Nettoyage FAP professionnel',
        action: 'book_cleaning'
      });
    }

    // Diagnostic bas√© sur les sympt√¥mes uniquement
    else {
      diagnosis += "**Analyse bas√©e sur vos sympt√¥mes :**\n\n";
      
      if (collectedData.fap_symptom_detection === 'oui') {
        diagnosis += "‚úÖ Voyant FAP allum√©\n";
      }
      if (collectedData.fap_physical_symptoms === 'oui') {
        diagnosis += "‚úÖ Perte de puissance confirm√©e\n";
      }
      if (collectedData.urban_fap_issue) {
        diagnosis += "‚ö†Ô∏è Conduite urbaine probl√©matique pour le FAP\n\n";
        diagnosis += "**Recommandation :** Votre FAP a besoin de r√©g√©n√©ration urgente.\n\n";
        
        ctas.push({
          type: 'education',
          text: 'üìö Comprendre la r√©g√©n√©ration FAP',
          action: 'learn_regeneration'
        });
      }
    }

    return {
      message: diagnosis,
      source: 'fap_expert',
      confidence: confidence,
      ctas: ctas,
      type: 'fap_diagnosis',
      conversationState: { ...conversationState, step: 'completed' }
    };
  }

  handleNonFAPIssue(userMessage) {
    console.log('üîç Recherche dans base autres probl√®mes...');
    
    const messageLower = userMessage.toLowerCase();
    const matchingIssue = this.otherDB.find(issue => 
      issue.keywords.some(keyword => messageLower.includes(keyword))
    );

    if (matchingIssue) {
      console.log(`‚úÖ Probl√®me trouv√©: ${matchingIssue.id}`);
      return {
        message: `üîß **${matchingIssue.symptomes}**\n\nüîç **Causes probables :** ${matchingIssue.causes_probables}\n\n‚úÖ **Solution :** ${matchingIssue.solution}`,
        source: 'database',
        confidence: matchingIssue.confidence,
        ctas: [
          {
            type: 'diagnostic',
            text: 'üîç Diagnostic en atelier',
            action: 'book_diagnostic'
          }
        ]
      };
    }

    console.log('ü§ñ Fallback vers Claude...');
    return this.handleGeneralQuery(userMessage);
  }

  async handleGeneralQuery(userMessage) {
    // Fallback vers Claude pour les cas non couverts
    const aiResponse = await this.getClaudeResponse(userMessage);
    
    return {
      message: aiResponse || "D√©sol√©, je ne peux pas analyser ce probl√®me sp√©cifique. Pouvez-vous me donner plus de d√©tails ou me parler d'un probl√®me de FAP ?",
      source: 'AI',
      confidence: 0.7,
      ctas: [
        {
          type: 'contact',
          text: 'üìû Parler √† un expert',
          action: 'contact_expert'
        }
      ]
    };
  }

  async getClaudeResponse(message) {
    if (!CLAUDE_API_KEY) return null;
    
    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'x-api-key': CLAUDE_API_KEY,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-sonnet-20240229',
          max_tokens: 400,
          messages: [{
            role: 'user',
            content: `Tu es Julien, expert automobile sp√©cialis√© FAP Re-Fap. Question: ${message}`
          }]
        })
      });

      const data = await response.json();
      return data.content?.[0]?.text;
    } catch (error) {
      console.error('‚ùå Erreur Claude:', error);
      return null;
    }
  }

  calculateFAPConfidence(collectedData) {
    let confidence = 0;
    let dataPoints = 0;

    Object.keys(collectedData).forEach(key => {
      if (collectedData[key] && key !== 'initial_query') {
        dataPoints++;
        if (key === 'detectedCode') confidence += 0.4;
        else if (key.includes('symptom')) confidence += 0.2;
        else confidence += 0.1;
      }
    });

    return Math.min(confidence, 0.95);
  }

  canProvideFAPDiagnosis(conversationState) {
    const { collectedData, detectedCode } = conversationState;
    
    // Si code d'erreur d√©tect√© = diagnostic imm√©diat
    if (detectedCode) return true;
    
    // Si assez de donn√©es collect√©es
    const keyData = ['fap_symptom_detection', 'fap_physical_symptoms', 'fap_driving_analysis'];
    const collectedKeyData = keyData.filter(key => collectedData[key]).length;
    
    return collectedKeyData >= 2;
  }
}

// ==================== ROUTES ====================
const fapEngine = new ConversationalFAPEngine();

// Sessions de conversation (en m√©moire pour la d√©mo)
const conversationSessions = new Map();

app.post('/api/chat', async (req, res) => {
  try {
    const { message, sessionId = 'default' } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message requis' });
    }

    // R√©cup√©rer ou cr√©er session
    const conversationState = conversationSessions.get(sessionId);
    
    // Traiter le message
    const result = await fapEngine.processMessage(message, conversationState);
    
    // Sauvegarder l'√©tat de conversation
    if (result.conversationState) {
      conversationSessions.set(sessionId, result.conversationState);
    }
    
    res.json({
      success: true,
      ...result,
      sessionId: sessionId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erreur serveur:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      success: false
    });
  }
});

// Route de test FAP
app.get('/api/test-fap/:query', async (req, res) => {
  try {
    const result = await fapEngine.processMessage(req.params.query);
    res.json({
      query: req.params.query,
      result: result,
      debug: true
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Route de sant√©
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    services: {
      fap_expert: 'Conversationnel int√©gr√©',
      other_issues: `${OTHER_ISSUES_DATABASE.length} cas`,
      claude: CLAUDE_API_KEY ? 'Configur√©' : 'Manquant',
      openai: OPENAI_API_KEY ? 'Configur√©' : 'Manquant'
    },
    version: 'FAP Re-Fap Conversationnel Expert',
    conversation_steps: Object.keys(FAP_CONVERSATION_DATABASE.conversation_steps).length,
    error_codes: Object.keys(FAP_CONVERSATION_DATABASE.fap_error_codes).length
  });
});

// Reset session
app.post('/api/reset-session', (req, res) => {
  const { sessionId = 'default' } = req.body;
  conversationSessions.delete(sessionId);
  res.json({ success: true, message: 'Session r√©initialis√©e' });
});

// Servir le fichier HTML
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(port, () => {
  console.log(`üöÄ Serveur FAP Re-Fap conversationnel d√©marr√© sur le port ${port}`);
  console.log(`üîß Expert FAP: ${Object.keys(FAP_CONVERSATION_DATABASE.conversation_steps).length} √©tapes conversationnelles`);
  console.log(`üìä Autres cas: ${OTHER_ISSUES_DATABASE.length} probl√®mes couverts`);
  console.log(`ü§ñ Fallback: Claude API ${CLAUDE_API_KEY ? '‚úÖ' : '‚ùå'}`);
  console.log(`üîç Test: http://localhost:${port}/api/test-fap/voyant%20fap%20allume`);
});
